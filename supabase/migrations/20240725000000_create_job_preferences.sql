-- First, ensure the moddatetime function exists
CREATE OR REPLACE FUNCTION moddatetime()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Then, create the table
CREATE TABLE public.job_preferences (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    job_titles TEXT[] NOT NULL DEFAULT '{}',
    industries TEXT[] NOT NULL DEFAULT '{}',
    locations TEXT[] NOT NULL DEFAULT '{}',
    work_arrangement TEXT,
    salary_range_min INTEGER,
    salary_range_max INTEGER,
    employment_types TEXT[] NOT NULL DEFAULT '{}',
    company_sizes TEXT[] NOT NULL DEFAULT '{}',
    target_companies TEXT[] NOT NULL DEFAULT '{}',
    avoid_companies TEXT[] NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT job_preferences_user_id_key UNIQUE (user_id)
);

-- And finally, create policies and the trigger
ALTER TABLE public.job_preferences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to read their own preferences"
ON public.job_preferences FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Allow users to insert their own preferences"
ON public.job_preferences FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Allow users to update their own preferences"
ON public.job_preferences FOR UPDATE
USING (auth.uid() = user_id);

CREATE TRIGGER handle_updated_at
BEFORE UPDATE ON public.job_preferences
FOR EACH ROW
EXECUTE PROCEDURE moddatetime(); 